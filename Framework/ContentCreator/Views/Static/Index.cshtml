<template class="task-template">
	<section id="static-section" class="section js-section u-category-communication">
		<p>Prototype Editor</p>

		<code id="async-msg">
			(None)
		</code>

		<input class="form-control" id="graphName" />

		<div id="mainGraph" style="overflow:hidden; height: 250px; width:100%;">

			<svg id="connections" height="100%" width="100%" style="position:absolute;"></svg>
			<div id="mainGraphNodes" style="width:100%; height:100%; position:absolute;"></div>
		</div>

		<script>
			(function () {
				const { ipcRenderer } = require("electron");

				var obj;

				document.getElementById('graphName').addEventListener("input", doThing);

				function doThing() {
					obj.Name = this.value;
				}

				ipcRenderer.on('onReloadFile-reply', (event, arg) => {
					const message = arg;
					console.log(message);
					document.getElementById('async-msg').innerHTML = message;

					obj = JSON.parse(message);
					console.log(obj.Nodes);

					var nodeContainer = document.getElementById('mainGraphNodes');

					// Delete all children
					while (nodeContainer.firstChild) {
						nodeContainer.removeChild(nodeContainer.firstChild);
					}
					
					// Create nodes
					for (var nodeKey in obj.Nodes) {
						if (obj.Nodes.hasOwnProperty(nodeKey)) {

                            const nodeValue = obj.Nodes[nodeKey];
                            const nodeData = nodeValue["Data"];
                            const nodeType = nodeValue["Type"];
							const editorData = nodeValue["_Editor"];
							const nodeGraphic = document.createElement("div");

							console.log(nodeKey, nodeValue);

							nodeGraphic.classList.add("node");

							nodeGraphic.style.left = editorData["Position"]["x"] + "px";
							nodeGraphic.style.top = editorData["Position"]["y"] + "px";

                            nodeContainer.appendChild(nodeGraphic);

                            const headerGraphic = document.createElement("div");
                            headerGraphic.innerHTML = nodeType;
                            headerGraphic.classList.add("nodeHeader");

                            nodeGraphic.appendChild(headerGraphic);

                            // Add Text Elements
                            for (const nodeDataKey in nodeData) {
                                if (nodeData.hasOwnProperty(nodeDataKey)) {
                                    const inputGraphic = document.createElement("input");
                                    inputGraphic.value = nodeData[nodeDataKey];
                                    
                                    inputGraphic.addEventListener("input", updateNodeText);
                                    function updateNodeText() {
                                        nodeData[nodeDataKey] = this.value;
                                    }

                                    nodeGraphic.appendChild(inputGraphic);
                                }
                            }

                            // Draggable Nodes
							nodeGraphic.onmousedown = function (event) {

								let shiftX = event.clientX - nodeGraphic.getBoundingClientRect().left;
								let shiftY = event.clientY - nodeGraphic.getBoundingClientRect().top;
                                
								// nodeGraphic.style.zIndex = 1000;

								moveAt(event.pageX, event.pageY);
                                
                                function moveAt(pageX, pageY) {
                                    var destX = pageX - shiftX - nodeContainer.getBoundingClientRect().x;
                                    var destY = pageY - shiftY - nodeContainer.getBoundingClientRect().y;

                                    nodeGraphic.style.left = destX + 'px';
                                    nodeGraphic.style.top = destY + 'px';

                                    editorData["Position"]["x"] = destX;
                                    editorData["Position"]["y"] = destY;
								}

								function onMouseMove(event) {
									moveAt(event.pageX, event.pageY);
								}
                                
								document.addEventListener('mousemove', onMouseMove);
                                
								nodeGraphic.onmouseup = function () {
									document.removeEventListener('mousemove', onMouseMove);
									nodeGraphic.onmouseup = null;
								};
							};

							nodeGraphic.ondragstart = function () {
								return false;
							};
						}
					}
					document.getElementById('graphName').value = obj.Name;
				});

				ipcRenderer.on('requestSave-reply', (event, arg) => {
					console.log(obj.Name);
					ipcRenderer.send('saveActiveDocument', JSON.stringify(obj, null, 4));
				});
			}());
		</script>

		<style>
            .node {
                position: absolute;
                width: 200px;
                background-color: #eee;
                border-radius: 5px;
                box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
                padding: 0px;
            }

            .node input {
                margin: 6px;
            }

			.nodeHeader {
				background-color: #e2e2e2;
				border-top-left-radius: 5px;
				border-top-right-radius: 5px;
				font-weight: bold;
				padding: 2px;
				text-align: center;
			}

			.connection {
				stroke: #9bc15e;
				stroke-width: 8px;
				fill: none;
			}

			.outputColumn {
				left: 100%;
				width: 20px;
				height: 100%;
				position: absolute;
				cursor: default;
			}

			.inputColumn {
				left: -20px;
				width: 20px;
				height: 100%;
				position: absolute;
				cursor: default;
			}

			.outputsocket {
				background-color: #bbb;
				border-top-right-radius: 5px;
				border-bottom-right-radius: 5px;
				cursor: default;
				height: 20px;
				margin: 4px 0px;
			}

			.inputsocket {
				background-color: #bbb;
				border-top-left-radius: 5px;
				border-bottom-left-radius: 5px;
				cursor: default;
				height: 20px;
				margin: 4px 0px;
			}

			.control {
				position: relative;
				width: 100%;
			}

			.draggable {
				cursor: pointer;
				position: relative;
				width: 100%;
			}
		</style>
	</section>
</template>
